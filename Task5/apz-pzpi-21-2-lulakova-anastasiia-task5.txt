1 МОДЕЛЮВАННЯ  ПРОГРАМНОЇ СИСТЕМИ
1.1	Мета роботи


Метою лабораторної роботи є розробка мобільного програмного застосунку, що є частиною системи управління притулком, опис прийнятих інженерних рішень, побудова діаграм. Необхідно представити будову системи та її взаємодію з іншими частинами системи.


1.2	Моделювання програмної системи


	Для розгляду функціональності було створено декілька Use-Case діаграм для різних ролей системи. 
В системі взагалі є декілька ролей: адміністратор (директор), лікар, відповідальний за постачання. Функціонал адміністратора включає доступ до всіх можливостей інших ролей та управління персоналом (наведено на Use-Case діаграмі додатку А, рис. А1). 
Далі можна розглянути Use-Case діаграму для лікаря (наведено у додатку А, рис А2). На діаграмі можна побачити одного діючого актора – лікаря, що має можливість переглядати та оновлювати інформацію про тварину, умови її життя в вольєрі. 
Роль відповідального за постачання включає в себе контроль кількості продуктів та розхідних матеріалів а складі. Цей функціонал наведено на Use-Case діаграмі 3 (додаток А,  рис А3). 
Також функціонал адміністратора та послідовність його дій з тваринами можна побачити на діаграмі активності (додаток А, рис А4). На цій діаграмі наведено можливі функції та дії адміна (директора) з тваринами: перегляд даних тварини, їх редагування, перегляд та редагування сенсору, воль’єру (умов в воль’єрі), перегляд даних сенсорів. Для всіх змін адміністратору необхідно підтверджувати особистість за допомогою вводу паролю та пройти перевірку на рівень доступу.


1.3	Взаємодія між частинами системи


Взаємодія клієнтської частини з іншими частинами системи буде відбуватися через серверну частину, до якої будуть робитися HTTP-запити, а саме: GET, POST, PUT, DELETE. З серверної частини можуть повертатися дані у різному форматі: об’єкти – у JSON форматі, в якій серіалізуються отримані з бази даних об’єкти, повідомлення про успішне створення, редагування, видалення, оновлення даних – за допомогою різних кодів (основні – 401, 400, 404, 200, 500).  
В якості прикладу взаємодії було створено діаграму взаємодії на роботи адміністратора з працівниками (додаток А, рис. А5). На цій діаграмі можна докладніше поглянути на послідовність дій самої програми та як відбувається взаємодія з серверною частиною.
 
2	ПРОГРАМНА РЕАЛІЗАЦІЯ КЛІЄНТСЬКОЇ ЧАСТИНИ
2.1 Архітектура програмної системи


Мобільний програмний застосунок розроблено для операційної системи IOS за допомогою технології SwiftUI на мові програмування Swift. В цій технології використовується декларативний підхід для створення сторінок, тобто дизайн (елементи сторінки) пишуться разом із бізнес-логікою. Тобто немає окремих файлів для View. 
Використовується архітектура MVVM, тому проект-застосунку було поділено на декілька папок: папка з моделями, які використовуються і у серверній частини, і у базі даних, та DTO-моделями (data transfer object), які містять не всі поля класу, а тільки ті, що не містять вразливої інформації а також у моделях існують методи для отримання відповідних даних з серверної частини. Об’єкти DTO отримуються з сервера або передаються на нього (наприклад, при реєстрації та авторизації, отримання даних про працівників), папка зі сторінками (Views), папка з вью-моделями (Viewmodel), що є проміжних шаром між моделю та View і необхідна для трансформації або додаткової обробки даних, що приходять з серверної частини, для правильного відображення на сторінці View.
В системі реалізовано локалізацію англійською та українською, тобто змінюється мова інтерфейсу, формат дати, для чого було створено 2 файли ресурсів (String Catalog), в яких у вигляді ключа-значення знаходиться текст, що використовується на сторінках. Локалізація змінюється у відповідному розділі налаштувань у вигляді меню, з якого можна обрати необхідну мову. Також у цьому ж розділі можна обрати шкалу вимірювання температури, Цельсії або Фаренгейти. Всі налаштування зберігаються у пам’яті, виділеною для додатку, тому вони запам’ятовуються між запусками додатку, через що не порібнокожен раз перелаштовувати систему.
Клієнтська частина взаємодіє з серверною за допомогою HTTP-запитів (GET, POST, PUT, DELETE).


2.2 Програмна розробка системи


Для візуалізації взаємодії моделей (класів) між собою було розроблено діаграму компонентів (додаток А, рис. А6).
Далі буде наведено повний процес перегляду тварин. Спочатку користувач авторизувався, після чого його переносить на сторінку всіх тварин. У цьому коді наведено приклад функції для отримання списку тварин із сервера:
1	public static func GetAllAnimals(completion: @escaping (Result<Array<Animal>, Error>) -> Void) {
2	  let url = "api/Animals"
3	  
4	  let httpClient = HttpClient.createRequest(url: url, method: .GET)
5	  if(httpClient == nil){
6	      completion(Result.failure(AnimalError.programError))
7	      return
8	  }
9	  
10	let task = URLSession.shared.dataTask(with: httpClient!){ (data, response, error) in
11	      
12	   if(!HttpClient.checkResponseAndError(response: response, error: error)){
13	      return
14	   }
15	      
16	  if let data = data {
17	    do {
18	        if let jsonString = String(data: data, encoding: .utf8) {
19	           print("Received JSON: \(jsonString)")
20	        }
21	        var decodedData = try JSONDecoder().decode(Array<Animal>.self, from: data)
22	        completion(.success(decodedData))
23	    } catch {
24	        print("Decoding error: \(error.localizedDescription)")
25	        print(error)
26	        completion(.failure(error))
27	    }
28	   }
29	  }
30	 task.resume()
31	}

Функція GetAllAnimals викликається з параметром completion, який є замиканням для обробки результату (рядок 1), створюється URL-рядок для запиту (рядок 2), після чого ініціалізується об'єкт HttpClient для виконання GET-запиту на вказаний URL (рядок 4). Якщо HttpClient не створено, викликається замикання completion з помилкою (рядки 5-7). Створюється завдання сесія для виконання запиту (рядок 9), далі перевіряється наявність помилок у відповіді сервера за допомогою відповідного методу (рядок 11). Якщо отримано дані (рядок 16), вони декодуються з формату JSON в масив об'єктів Animal (рядки 21-23), і у разі успішного декодування викликається замикання completion з результатом успіху і переданими даними (рядок 22). У разі виникнення помилки при декодуванні, помилка виводиться на консоль і викликається замикання completion з результатом невдачі (рядки 24-26). В кінці це завдання з запитом викликається. 
Таким чином, цей код виконує GET-запит до API для отримання списку тварин, обробляє відповідь сервера, декодує отримані дані з формату JSON у масив об'єктів Animal, і повертає результат через замикання completion. У разі виникнення помилок, вони обробляються і передаються у замиканні.
Для показу динамічного створення сторінок, тобто коли інформація різна, але повинна однаково відображатися на сторінці, як, наприклад, сторінка редактора тварини, наведено код у додатку А. Цей код представляє структуру AnimalEditorView, яка є представленням у SwiftUI для редагування даних про тварину. Структура приймає об'єкт типу Animal, з яким працює через прив'язку @Binding, і замикання updateInDB, яке викликається для оновлення даних у базі даних. Також визначено стан @State для збереження дати народження (dob) (рядки 1-4).
Основне тіло представлення складається з форми, яка містить дві секції. У першій секції користувач може вводити або редагувати ім'я тварини через текстове поле, яке прив'язане до властивості name об'єкта animal(рядки 9-12). У другій секції знаходяться текстові поля для породи та статі тварини, розміщені в горизонтальному стеку (рядки 13-15). Далі у вертикальному стеку розміщено вибір дати для дати народження та текстове поле для введення ваги тварини, яке використовує спеціальний форматер для числових (рядки 16-23).
Коли представлення зникає, обробник onDisappear (рядки 28-31) оновлює властивість dob об'єкта animal з використанням конвертера дат і викликає замикання updateInDB, щоб зберегти зміни у базі даних. У кінці визначено числовий форматер (рядки 34-37), який налаштовується для використання з полем введення ваги.
В якості прикладу обробки замикання буде виступати метод для реєстрації користувача, що знаходиться у вьюмоделі користувача:
1	 public func RegisterUser(completion: @escaping (Result<Bool, Error>) -> Void){
2	        model.RegisterUser {result in
3	            switch result {
4	            case .success(true):
5	                self.model.GetUser(completion: completion)
6	            default:
7	                return
8	            }
9	        }
10	    }

Функція приймає замикання completion, яке обробляє результат операції і може повертати значення типу Result<Bool, Error> (рядок 1). Всередині функції викликається метод RegisterUser об'єкта model, який також приймає замикання як параметр (рядок 2). При отриманні результату виконується перевірка за допомогою оператора switch(рядки 3-8). Якщо результат є успішним (.success(true)), викликається метод GetUser об'єкта model (рядок 5), який передає отримане completion для обробки результату та що призначений для авторизації після реєстрації нового користувача. У всіх інших випадках функція просто повертається без додаткових дій. Таким чином, функція RegisterUser спочатку реєструє користувача, а у разі успіху виконує додатковий запит для отримання даних про користувача, передаючи результат через замикання completion.
	В системі є локалізація. Доступні 2 мови: англійська та українська. При виборі мови вона зберігається у пам’яті пристрою, тому залишається однією і тою ж самою в різних запусках додатку. Час модифікується відповідно до часового поясу (регіону), на який налаштован сам телефон. Також при включенні української мови дата має синій колір, якщо вона за зимовим часом, червоним – за літнім. Є можливість вибору шкали температури, Цельсій або Фаренгейт.
В додатку А наведено View-модель для складу, в якій є методи для отримання наявності складу, отримання всіх замовлень та оновлення статусу замовлення.


2.3 Висновки


Впродовж цієї лабораторної роботи мною було розроблено мобільний програмний застосунок, що є частиною програмної системи по управлінню притулком, описано архітектуру системи, програмну реалізацію, розроблено Use Case діаграми, діаграми активності та взаємодії. 
 
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ


1.	Посилання на репозиторій з кодом: https://github.com/NureLulakovaAnastasiia/apz-pzpi-21-2-lulakova-anastasiia/tree/main/Task5/apz-pzpi-21-2-lulakova-anastasiia-task5    
2.	Посилання на відеозапис: https://youtu.be/JUZIPBpPLtg 
